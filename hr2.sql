SET SERVEROUT ON

DECLARE 
    E_ID EMPLOYEES.EMPLOYEE_ID%TYPE;
    E_NAME EMPLOYEES.FIRST_NAME%TYPE;
    E_LNAME EMPLOYEES.LAST_NAME%TYPE;
    D_NAME DEPARTMENTS.DEPARTMENT_NAME%TYPE;

BEGIN
SELECT EMPLOYEE_ID, FIRST_NAME, LAST_NAME, DEPARTMENT_NAME INTO E_ID,E_NAME, E_LNAME, D_NAME
FROM EMPLOYEES JOIN DEPARTMENTS ON EMPLOYEES.DEPARTMENT_ID = DEPARTMENTS.DEPARTMENT_ID AND EMPLOYEE_ID = 102;

DBMS_OUTPUT.PUT_LINE('EMPLOYEE ID: '|| E_ID);
DBMS_OUTPUT.PUT_LINE('EMPLOYEE FIRST NAME: '|| E_NAME);    
DBMS_OUTPUT.PUT_LINE('EMPLOYEE LAST NAME: '|| E_LNAME);
DBMS_OUTPUT.PUT_LINE('DEPARTMENT_NAME '|| D_NAME);    

END;
--
SET SERVEROUT ON

DECLARE
    E_ID EMPLOYEES.EMPLOYEE_ID%TYPE := 100;
    E_SALARY EMPLOYEES.SALARY%TYPE;
    E_FNAME EMPLOYEES.FIRST_NAME%TYPE;
    E_LAST EMPLOYEES.LAST_NAME%TYPE;
    DEPT EMPLOYEES.DEPARTMENT_ID%TYPE;

BEGIN
    SELECT FIRST_NAME, LAST_NAME, DEPARTMENT_ID, SALARY INTO E_FNAME, E_LAST, DEPT, E_SALARY
    FROM EMPLOYEES 
    WHERE EMPLOYEE_ID = E_ID;

    IF E_ID = 100 THEN
        UPDATE EMPLOYEES SET SALARY = E_SALARY + 100 WHERE EMPLOYEE_ID = E_ID;
        DBMS_OUTPUT.PUT_LINE('SALARY UPDATE ' || E_SALARY);

    ELSIF E_ID = 50 THEN
        UPDATE EMPLOYEES SET SALARY = E_SALARY + 500 WHERE EMPLOYEE_ID = E_ID;
        DBMS_OUTPUT.PUT_LINE('SALARY UPDATE ' || E_SALARY);

    ELSIF E_ID = 40 THEN
        UPDATE EMPLOYEES SET SALARY = E_SALARY + 350 WHERE EMPLOYEE_ID = E_ID;
        DBMS_OUTPUT.PUT_LINE('SALARY UPDATE ' || E_SALARY);

    ELSE
        DBMS_OUTPUT.PUT_LINE('NO SUCH RECORD');
    END IF;
END;


SET SERVEROUT ON 

DECLARE
    E_ID EMPLOYEES.EMPLOYEE_ID%TYPE := 100;
    E_SALARY EMPLOYEES.SALARY%TYPE;
    E_FNAME EMPLOYEES.FIRST_NAME%TYPE;
    E_LAST EMPLOYEES.LAST_NAME%TYPE;
    DEPT EMPLOYEES.DEPARTMENT_ID%TYPE;
    
BEGIN
    -- Fetch employee details based on EMPLOYEE_ID
    SELECT FIRST_NAME, LAST_NAME, DEPARTMENT_ID, SALARY INTO E_FNAME, E_LAST, DEPT, E_SALARY
    FROM EMPLOYEES 
    WHERE EMPLOYEE_ID = E_ID;
    
    -- Check conditions and update salary accordingly
    IF E_ID = 100 THEN
        IF E_SALARY < 1000 THEN
            UPDATE EMPLOYEES 
            SET SALARY = SALARY + (SALARY * 0.1) 
            WHERE EMPLOYEE_ID = E_ID;
            DBMS_OUTPUT.PUT_LINE('Updated salary: ' || E_SALARY);

        ELSIF E_SALARY > 1000 AND E_SALARY < 1500 THEN
            UPDATE EMPLOYEES 
            SET SALARY = SALARY + (SALARY * 0.15) 
            WHERE EMPLOYEE_ID = E_ID;
            DBMS_OUTPUT.PUT_LINE('Updated salary: ' || E_SALARY);

        ELSIF E_SALARY > 1500 THEN
            UPDATE EMPLOYEES 
            SET SALARY = SALARY + (SALARY * 0.2) 
            WHERE EMPLOYEE_ID = E_ID;
            DBMS_OUTPUT.PUT_LINE('Updated salary: ' || E_SALARY);

        ELSE
            DBMS_OUTPUT.PUT_LINE('NO BONUS');
        END IF;
    END IF;

END;


SET SERVEROUT ON;

DECLARE
    E_ID EMPLOYEES.EMPLOYEE_ID%TYPE;
    E_SALARY EMPLOYEES.SALARY%TYPE;
    E_COMMISSION EMPLOYEES.COMMISSION_PCT%TYPE;
BEGIN
    E_ID := &employee_id;  -- Prompt user for Employee ID

    SELECT SALARY, COMMISSION_PCT INTO E_SALARY, E_COMMISSION
    FROM EMPLOYEES
    WHERE EMPLOYEE_ID = E_ID;

    IF E_COMMISSION IS NULL THEN
        UPDATE EMPLOYEES 
        SET SALARY = E_SALARY + 500  
        WHERE EMPLOYEE_ID = E_ID;

        DBMS_OUTPUT.PUT_LINE('Employee ' || E_ID || ' had NULL commission. Salary updated.');
    ELSE
        DBMS_OUTPUT.PUT_LINE('Employee ' || E_ID || ' has a valid commission. No update needed.');
    END IF;
    
    COMMIT;
END;
    
CREATE OR REPLACE VIEW EMP_Det AS
SELECT DISTINCT EMPLOYEES.EMPLOYEE_ID, EMPLOYEES.FIRST_NAME,
EMPLOYEES.EMAIL, DEPARTMENTS.DEPARTMENT_NAME 
FROM EMPLOYEES 
INNER JOIN DEPARTMENTS
ON EMPLOYEES.DEPARTMENT_ID = DEPARTMENTS.DEPARTMENT_ID
WHERE EMPLOYEES.DEPARTMENT_ID = 80;

SELECT * FROM emp_det;
SELECT * FROM employees;
UPDATE emp_det SET FIRST_NAME = 'Ali' WHERE EMPLOYEE_ID = 170;
DELETE FROM emp_det WHERE EMPLOYEE_ID = 170;

CREATE OR REPLACE VIEW JOB_COUNT AS SELECT JOB_ID AS DESIGNATION, COUNT(EMPLOYEE_ID) AS EMPLOYEES_NUM
FROM EMPLOYEES GROUP BY JOB_ID;

CREATE OR REPLACE VIEW DETAILS AS SELECT EMPLOYEE_ID, FIRST_NAME, DEPARTMENT_ID FROM EMPLOYEES 
WHERE FIRST_NAME <> 'King';

CREATE OR REPLACE VIEW EMPLOYEES_DEPT_DETAILS AS
SELECT EMPLOYEES.EMPLOYEE_ID AS EMPNO, EMPLOYEES.FIRST_NAME AS EMPNAME, 
       EMPLOYEES.DEPARTMENT_ID AS DEPTNO, DEPARTMENTS.DEPARTMENT_NAME AS DEPTNAME
FROM EMPLOYEES
JOIN DEPARTMENTS ON EMPLOYEES.DEPARTMENT_ID = DEPARTMENTS.DEPARTMENT_ID;


SET SERVEROUTPUT ON;

DECLARE
    num1 NUMBER;
    num2 NUMBER;
    sum_result NUMBER;
BEGIN
    DBMS_OUTPUT.PUT_LINE('Enter the first number:');
    num1 := &num1;

    DBMS_OUTPUT.PUT_LINE('Enter the second number:');
    num2 := &num2;

    sum_result := num1 + num2;

    DBMS_OUTPUT.PUT_LINE('The sum of ' || num1 || ' and ' || num2 || ' is: ' || sum_result);
END;


SET SERVEROUTPUT ON;

DECLARE
    v_emp_id EMPLOYEES.EMPLOYEE_ID%TYPE;
    v_first_name EMPLOYEES.FIRST_NAME%TYPE;
    v_last_name EMPLOYEES.LAST_NAME%TYPE;
    v_email EMPLOYEES.EMAIL%TYPE;
    v_phone_number EMPLOYEES.PHONE_NUMBER%TYPE;
    v_hire_date EMPLOYEES.HIRE_DATE%TYPE;
    v_job_id EMPLOYEES.JOB_ID%TYPE;
    v_salary EMPLOYEES.SALARY%TYPE;
    v_commission_pct EMPLOYEES.COMMISSION_PCT%TYPE;
    v_manager_id EMPLOYEES.MANAGER_ID%TYPE;
    v_dept_id DEPARTMENTS.DEPARTMENT_ID%TYPE;
    v_dept_name DEPARTMENTS.DEPARTMENT_NAME%TYPE;
    v_location_id DEPARTMENTS.LOCATION_ID%TYPE;
BEGIN
    DBMS_OUTPUT.PUT_LINE('Enter Employee ID:');
    v_emp_id := &v_emp_id;

    DBMS_OUTPUT.PUT_LINE('Enter First Name:');
    v_first_name := &v_first_name;

    DBMS_OUTPUT.PUT_LINE('Enter Last Name:');
    v_last_name := &v_last_name;

    DBMS_OUTPUT.PUT_LINE('Enter Email:');
    v_email := &v_email;

    DBMS_OUTPUT.PUT_LINE('Enter Phone Number:');
    v_phone_number := &v_phone_number;

    DBMS_OUTPUT.PUT_LINE('Enter Hire Date (YYYY-MM-DD):');
    v_hire_date := TO_DATE(&v_hire_date, 'YYYY-MM-DD');

    DBMS_OUTPUT.PUT_LINE('Enter Job ID:');
    v_job_id := &v_job_id;

    DBMS_OUTPUT.PUT_LINE('Enter Salary:');
    v_salary := &v_salary;

    DBMS_OUTPUT.PUT_LINE('Enter Commission Percentage (if applicable):');
    v_commission_pct := &v_commission_pct;

    DBMS_OUTPUT.PUT_LINE('Enter Manager ID:');
    v_manager_id := &v_manager_id;

    DBMS_OUTPUT.PUT_LINE('Enter Department ID:');
    v_dept_id := &v_dept_id;

    DBMS_OUTPUT.PUT_LINE('Enter Department Name:');
    v_dept_name := &v_dept_name;

    DBMS_OUTPUT.PUT_LINE('Enter Location ID:');
    v_location_id := &v_location_id;

    INSERT INTO DEPARTMENTS (DEPARTMENT_ID, DEPARTMENT_NAME, LOCATION_ID)
    VALUES (v_dept_id, v_dept_name, v_location_id);

    INSERT INTO EMPLOYEES (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
    VALUES (v_emp_id, v_first_name, v_last_name, v_email, v_phone_number, v_hire_date, v_job_id, v_salary, v_commission_pct, v_manager_id, v_dept_id);

    DBMS_OUTPUT.PUT_LINE('Employee and Department data inserted successfully.');
END;


SET SERVEROUT ON

CREATE OR REPLACE PROCEDURE UPDATE_SALARY (emp_no in employees.employee_id%TYPE) IS v_current_salary EMPLOYEES.SALARY%TYPE);

BEGIN 
    SELECT SALARY INTO v_current_salary
    FROM EMPLOYEES WHERE EMPLOYEE_ID = emp_no
    
    UPDATE EMPLOYEES SET SALARY = v_current_salary + (v_current_salary*0.10)
    WHERE EMPLOYEE_ID = emp_no
    
    DBMS_OUTPUT.PUT_LINE('Salary updated for employee ID ' || emp_no || ' by 10%.');
    COMMIT;
        
    EXCEPTION
    WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('No employee found with ID ' || p_empno);
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error occurred: ' || SQLERRM);

END UPDATE_SALARY;

EXEC UPDATE_SALARY(101);


SET SERVEROUTPUT ON;

DECLARE 
    EMP_ID EMPLOYEES.EMPLOYEE_ID%TYPE;
    E_MID EMPLOYEES.MANAGER_ID%TYPE;
    E_SALARY EMPLOYEES.SALARY%TYPE;
    
BEGIN 
    EMP_ID := :&EMP_ID;
    
    LOOP
        SELECT MANAGER_ID, SALARY INTO E_MID, E_SALARY 
        FROM EMPLOYEES 
        WHERE EMPLOYEE_ID = EMP_ID;
        
        IF E_SALARY > 2500 THEN
            DBMS_OUTPUT.PUT_LINE('First employee with salary over 2500: ' || EMP_ID);
            EXIT;
        END IF;
        
        EMP_ID := E_MID;
        EXIT WHEN E_MID IS NULL;
    END LOOP;
END;


SET SERVEROUTPUT ON;

DECLARE
    sum1 NUMBER := 0;
    counter NUMBER := 1;
BEGIN
    FOR counter IN 1..100 LOOP
        sum1 := sum1 + counter;
    END LOOP;

    DBMS_OUTPUT.PUT_LINE('Sum of the first 100 numbers: ' || sum1);
END;

--JOINS
SELECT 
    E.FIRST_NAME AS EMPLOYEE_FIRST_NAME,
    E.LAST_NAME AS EMPLOYEE_LAST_NAME,
    E.HIRE_DATE AS EMPLOYEE_HIRE_DATE,
    M.HIRE_DATE AS MANAGER_HIRE_DATE
FROM 
    EMPLOYEES E
JOIN 
    EMPLOYEES M ON E.MANAGER_ID = M.EMPLOYEE_ID
WHERE 
    E.HIRE_DATE > M.HIRE_DATE;
--
SELECT 
    E.EMPLOYEE_ID AS EMPLOYEE_ID,
    E.FIRST_NAME AS EMPLOYEE_FIRST_NAME,
    E.LAST_NAME AS EMPLOYEE_LAST_NAME,
    M.EMPLOYEE_ID AS MANAGER_ID,
    M.FIRST_NAME AS MANAGER_FIRST_NAME,
    M.LAST_NAME AS MANAGER_LAST_NAME
FROM 
    EMPLOYEES E
LEFT JOIN 
    EMPLOYEES M ON E.MANAGER_ID = M.EMPLOYEE_ID;
    
--
SELECT E.FIRST_NAME, J.JOB_TITLE, MAX(E.SALARY) AS MAX_SALARY, E.DEPARTMENT_ID FROM EMPLOYEES E JOIN 
JOBS J ON E.JOB_ID = J.JOB_ID GROUP BY E.FIRST_NAME, J.JOB_TITLE, E.DEPARTMENT_ID;

SELECT D.DEPARTMENT_NAME FROM DEPARTMENTS D LEFT JOIN EMPLOYEES E ON E.DEPARTMENT_ID = D.DEPARTMENT_ID AND E.HIRE_DATE > ADD_MONTHS(SYSDATE, -36)
GROUP BY D.DEPARTMENT_NAME HAVING COUNT(E.EMPLOYEE_ID) = 0;

SELECT J.JOB_TITLE,COUNT(E.EMPLOYEE_ID) FROM JOBS J LEFT JOIN EMPLOYEES E ON J.JOB_ID = E.JOB_ID GROUP BY JOB_TITLE HAVING COUNT(E.EMPLOYEE_ID) = 0;
    
SELECT D.DEPARTMENT_NAME, AVG(E.SALARY), MAX(E.SALARY) FROM EMPLOYEES E JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID 
GROUP BY D.DEPARTMENT_NAME

SELECT E.FIRST_NAME, E.SALARY, D.DEPARTMENT_NAME FROM EMPLOYEES E JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID WHERE 
E.SALARY > (SELECT AVG(SALARY) FROM EMPLOYEES WHERE DEPARTMENT_ID = E.DEPARTMENT_ID);

SELECT E.DEPARTMENT_ID, D.DEPARTMENT_NAME, COUNT(E.EMPLOYEE_ID) FROM EMPLOYEES E RIGHT JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
GROUP BY E.DEPARTMENT_ID, D.DEPARTMENT_NAME HAVING COUNT(E.EMPLOYEE_ID)=0;

SELECT E.FIRST_NAME, L.CITY, L.STATE_PROVINCE,L.COUNTRY_ID FROM EMPLOYEES E JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID 
JOIN LOCATIONS L ON D.LOCATION_ID = L.LOCATION_ID WHERE L.STATE_PROVINCE = 'Washington' AND L.COUNTRY_ID = 'US'

--Triggers
CREATE TABLE EMPLOYEE_BONUS(
    emp_id number primary key,
    bonus number
)

CREATE OR REPLACE TRIGGER Update_bonus 
AFTER INSERT ON EMPLOYEES 
FOR EACH ROW

BEGIN INSERT INTO EMPLOYEE_BONUS(emp_id, bonus) values (:NEW.employee_id, :NEW.salary*0.10)

END;

INSERT INTO employees (employee_id, first_name, last_name, salary, department_id, job_id)
VALUES (101, 'John', 'Doe', 5000, 10, 'IT_PROG');
SELECT * FROM employee_bonus;


CREATE OR REPLACE TRIGGER CHECK_SALARY 
AFTER INSERT ON EMPLOYEES FOR EACH ROW

BEGIN

IF :NEW.SALARY > 10000 THEN
    RAISE_APPLICATION_ERROR(-20001, 'Error: Salary cannot exceed 10,000.');
    END IF;
END;

INSERT INTO employees (employee_id, first_name, last_name, salary, department_id, job_id)
VALUES (101, 'John', 'Doe', 9500, 10, 'IT_PROG');


CREATE TABLE Deleted_Employees_Log (
    log_id NUMBER PRIMARY KEY,
    employee_id NUMBER,
    first_name VARCHAR2(50),
    last_name VARCHAR2(50),
    department_id NUMBER,
    job_id VARCHAR2(10),
    salary NUMBER,
    deleted_at TIMESTAMP
);

CREATE OR REPLACE TRIGGER log_deleted_employees
AFTER DELETE ON employees
FOR EACH ROW
BEGIN
    -- Insert deleted record into Deleted_Employees_Log
    INSERT INTO Deleted_Employees_Log (
        log_id, 
        employee_id, 
        first_name, 
        last_name, 
        department_id, 
        job_id, 
        salary, 
        deleted_at
    )
    VALUES (
        Deleted_Employees_Log_SEQ.NEXTVAL, -- Assuming there's a sequence for generating log_id
        :OLD.employee_id,
        :OLD.first_name,
        :OLD.last_name,
        :OLD.department_id,
        :OLD.job_id,
        :OLD.salary,
        SYSDATE
    );
END;

DELETE FROM employees WHERE employee_id = 101;

CREATE TABLE Salary_Change_Log (
    log_id NUMBER PRIMARY KEY,
    employee_id NUMBER,
    old_salary NUMBER,
    new_salary NUMBER,
    change_date TIMESTAMP,
    changed_by VARCHAR2(50) -- Optionally, you can log who made the change
);

CREATE OR REPLACE TRIGGER log_salary_changes
AFTER UPDATE OF salary ON employees
FOR EACH ROW
BEGIN
     IF :OLD.salary != :NEW.salary THEN
        INSERT INTO Salary_Change_Log (
            log_id,
            employee_id,
            old_salary,
            new_salary,
            change_date,
            changed_by
        )
        VALUES (
            Salary_Change_Log_SEQ.NEXTVAL,
            :OLD.employee_id,
            :OLD.salary,
            :NEW.salary,
            SYSDATE,
            USER 
        );
    END IF;
END;

UPDATE employees
SET salary = 12000
WHERE employee_id = 101;

--DDL
CREATE TABLE AUDIT_LOG (
    TABLE_NAME VARCHAR2(255),
    CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CREATED_BY VARCHAR2(255)
);

CREATE OR REPLACE TRIGGER TRG_LOG_TABLE_CREATION   
AFTER CREATE ON DATABASE
DECLARE

    TABLE_NAME VARCHAR(255);
    V_USER VARCHAR(255);
    
BEGIN
    V_TABLE_NAME := ORA_DICT_OBJ_NAME;
    V_USER := SYS_CONTEXT('USERENV', 'CURRENT_USER');
    
    INSERT INTO AUDIT_LOG (TABLE_NAME, CREATED_AT, CREATED_BY)
    VALUES (V_TABLE_NAME, SYSTIMESTAMP, V_USER);
END;

CREATE OR REPLACE TRIGGER TRG_PREVENT_ALTER_OUTSIDE_HOURS
BEFORE ALTER ON SCHEMA
DECLARE
    V_HOUR NUMBER;
BEGIN
    V_HOUR := TO_NUMBER(TO_CHAR(SYSDATE, 'HH24'));

    IF V_HOUR < 8 OR V_HOUR >= 18 THEN
        IF ORA_DICT_OBJ_NAME = 'EMPLOYEES' THEN
            RAISE_APPLICATION_ERROR(-20002, 'ERROR: ALTER operations on EMPLOYEES table are restricted outside business hours (8 AM to 6 PM)');
        END IF;
    END IF;
END;

--3
CREATE TABLE DROP_LOG (
    TABLE_NAME VARCHAR2(255),
    DROPPED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    DROPPED_BY VARCHAR2(255)
);

CREATE OR REPLACE TRIGGER TRG_LOG_TABLE_DROP
AFTER DROP ON DATABASE
DECLARE
    V_TABLE_NAME VARCHAR2(255);
    V_USER VARCHAR2(255);
BEGIN
    V_TABLE_NAME := ORA_DICT_OBJ_NAME;
    V_USER := SYS_CONTEXT('USERENV', 'CURRENT_USER');
    
    INSERT INTO DROP_LOG (TABLE_NAME, DROPPED_AT, DROPPED_BY)
    VALUES (V_TABLE_NAME, SYSTIMESTAMP, V_USER);
END;

--4
CREATE OR REPLACE TRIGGER TRG_PREVENT_DROP_AUDIT_LOG
BEFORE DROP ON DATABASE
DECLARE
    V_TABLE_NAME VARCHAR2(255);
BEGIN
    V_TABLE_NAME := ORA_DICT_OBJ_NAME;
    IF V_TABLE_NAME = 'AUDIT_LOG' THEN
        RAISE_APPLICATION_ERROR(-20003, 'ERROR: Dropping the AUDIT_LOG table is not allowed.');
    END IF;
END;

Database Trigger Task:

--1
CREATE TABLE SYSTEM_LOGS (
    LOG_ID INT PRIMARY KEY,
    EVENT_TIME TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    STATUS VARCHAR2(50)
);

CREATE OR REPLACE TRIGGER TRG_LOG_DATABASE_STARTUP
AFTER STARTUP ON DATABASE
BEGIN
    INSERT INTO SYSTEM_LOGS (LOG_ID, EVENT_TIME, STATUS)
    VALUES (SYSTEM_LOGS_SEQ.NEXTVAL, SYSTIMESTAMP, 'DATABASE STARTED');
END;

--2
CREATE TABLE FAILED_LOGINS (
    LOG_ID INT PRIMARY KEY,
    USERNAME VARCHAR2(255),
    ATTEMPT_TIME TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    STATUS VARCHAR2(50)
);

AUDIT SESSION WHENEVER NOT SUCCESSFUL;

CREATE OR REPLACE PROCEDURE LOG_FAILED_LOGINS AS
BEGIN
    INSERT INTO FAILED_LOGINS (LOG_ID, USERNAME, ATTEMPT_TIME, STATUS)
    SELECT AUDIT_ID, USERNAME, EVENT_TIMESTAMP, 'FAILED'
    FROM UNIFIED_AUDIT_TRAIL
    WHERE ACTION_NAME = 'LOGON'
      AND RETURN_CODE != 0; 
END;

BEGIN
    DBMS_SCHEDULER.create_job (
        job_name        => 'JOB_LOG_FAILED_LOGINS',
        job_type        => 'PLSQL_BLOCK',
        job_action      => 'BEGIN LOG_FAILED_LOGINS; END;',
        start_date      => SYSTIMESTAMP,
        repeat_interval => 'FREQ=MINUTELY; INTERVAL=5',
        enabled         => TRUE
    );
END;

--4
CREATE TABLE USER_ACTIVITY_LOG (
    LOG_ID INT PRIMARY KEY,
    USERNAME VARCHAR2(255),
    LOGIN_TIME TIMESTAMP,
    LOGOUT_TIME TIMESTAMP,
    SESSION_DURATION INTERVAL DAY TO SECOND
);

AUDIT SESSION;

CREATE OR REPLACE PROCEDURE LOG_USER_ACTIVITY AS
BEGIN
    INSERT INTO USER_ACTIVITY_LOG (LOG_ID, USERNAME, LOGIN_TIME, LOGOUT_TIME, SESSION_DURATION)
    SELECT AUDIT_ID,
           USERNAME,
           MIN(CASE WHEN ACTION_NAME = 'LOGON' THEN EVENT_TIMESTAMP END) AS LOGIN_TIME,
           MAX(CASE WHEN ACTION_NAME = 'LOGOFF' THEN EVENT_TIMESTAMP END) AS LOGOUT_TIME,
           (MAX(CASE WHEN ACTION_NAME = 'LOGOFF' THEN EVENT_TIMESTAMP END) -
            MIN(CASE WHEN ACTION_NAME = 'LOGON' THEN EVENT_TIMESTAMP END)) AS SESSION_DURATION
    FROM UNIFIED_AUDIT_TRAIL
    WHERE ACTION_NAME IN ('LOGON', 'LOGOFF')
    AND USERNAME IS NOT NULL
    GROUP BY AUDIT_ID, USERNAME
    HAVING MAX(CASE WHEN ACTION_NAME = 'LOGOFF' THEN EVENT_TIMESTAMP END) IS NOT NULL
           AND MIN(CASE WHEN ACTION_NAME = 'LOGON' THEN EVENT_TIMESTAMP END) IS NOT NULL;
END;

BEGIN
    DBMS_SCHEDULER.create_job (
        job_name        => 'JOB_LOG_USER_ACTIVITY',
        job_type        => 'PLSQL_BLOCK',
        job_action      => 'BEGIN LOG_USER_ACTIVITY; END;',
        start_date      => SYSTIMESTAMP,
        repeat_interval => 'FREQ=MINUTELY; INTERVAL=5',
        enabled         => TRUE
    );
END;

--Instead of Trigger Task:

--1
CREATE OR REPLACE TRIGGER TRG_INSTEAD_INSERT_EMP_DEPT
INSTEAD OF INSERT ON EMPLOYEE_DEPT_VIEW
FOR EACH ROW
DECLARE
    V_DEPT_COUNT NUMBER;
BEGIN
    SELECT COUNT(*) INTO V_DEPT_COUNT
    FROM DEPARTMENTS
    WHERE DEPT_ID = :NEW.DEPT_ID;

    IF V_DEPT_COUNT = 0 THEN
        INSERT INTO DEPARTMENTS (DEPT_ID, DEPT_NAME)
        VALUES (:NEW.DEPT_ID, :NEW.DEPT_NAME);
    END IF;

    INSERT INTO EMPLOYEES (EMP_ID, NAME, SALARY, DEPT_ID)
    VALUES (:NEW.EMP_ID, :NEW.NAME, :NEW.SALARY, :NEW.DEPT_ID);
END;

--2
CREATE VIEW EMPLOYEE_SALARY_VIEW AS
SELECT EMP_ID, NAME, SALARY
FROM EMPLOYEES;

CREATE OR REPLACE TRIGGER TRG_PREVENT_SALARY_REDUCTION
INSTEAD OF UPDATE ON EMPLOYEE_SALARY_VIEW
FOR EACH ROW
BEGIN
    IF :NEW.SALARY < :OLD.SALARY * 0.8 THEN
        RAISE_APPLICATION_ERROR(-20004, 'error salary reduction exceeds the allowed 20% limit');
    ELSE
        UPDATE EMPLOYEES
        SET SALARY = :NEW.SALARY
        WHERE EMP_ID = :OLD.EMP_ID;
    END IF;
END;

--Transactions
CREATE TABLE INVENTORY(
PRODUCT_ID NUMBER PRIMARY KEY,
    PRODUCT_NAME VARCHAR2(50),
    STOCK NUMBER,
    PRICE NUMBER
)

CREATE TABLE RETURNS (
    RETURN_ID NUMBER PRIMARY KEY,
    PRODUCT_ID NUMBER,
    RETURN_DATE DATE,
    REASON VARCHAR2(100),
    QUANTITY NUMBER,
    FOREIGN KEY (PRODUCT_ID) REFERENCES INVENTORY(PRODUCT_ID)
);

INSERT INTO INVENTORY (PRODUCT_ID, PRODUCT_NAME, STOCK, PRICE) VALUES (1,'Laptop',50,1200);
INSERT INTO INVENTORY (PRODUCT_ID, PRODUCT_NAME, STOCK, PRICE) VALUES (2,'Mobile Phone',100,800);
INSERT INTO INVENTORY (PRODUCT_ID, PRODUCT_NAME, STOCK, PRICE) VALUES (3,'Tablet',75,500);

INSERT INTO RETURNS (RETURN_ID, PRODUCT_ID, RETURN_DATE, REASON, QUANTITY) VALUES (101,1,SYSDATE,'Damaged',5);
INSERT INTO RETURNS (RETURN_ID, PRODUCT_ID, RETURN_DATE, REASON, QUANTITY) VALUES (102,2,SYSDATE,'Unsatisfied',3);
INSERT INTO RETURNS (RETURN_ID, PRODUCT_ID, RETURN_DATE, REASON, QUANTITY) VALUES (103,3,SYSDATE,'Incorrect Item',2);

SELECT P.PRODUCT_NAME, SUM(R.QUANTITY) AS TOTAL_RETURNED FROM INVENTORY P JOIN RETURNS R ON P.PRODUCT_ID = R.PRODUCT_ID GROUP BY P.PRODUCT_NAME;

SELECT P.PRODUCT_NAME, SUM(R.QUANTITY) AS TOTAL_RETURNED, SUM(R.QUANTITY * P.PRICE * 0.05) AS RESTOCKING_FEE FROM INVENTORY P JOIN RETURNS R ON P.PRODUCT_ID = R.PRODUCT_ID GROUP BY P.PRODUCT_NAME;

--transaction
BEGIN
SAVEPOINT STOCK_UPDATE
INSERT INTO RETURNS (RETURN_ID,PRODUCT_ID, RETURN_DATE, REASON, QUANTITY) VALUES (104,2,SYSDATE,'Customer Change of Mind',4);

DECLARE RESTOCKING_FEE NUMBER;
BEGIN
SELECT (4*PRICE*0.05) INTO RESTOCKING_FEE
FROM INVENTORY WHERE PRODUCT_ID = 2;

UPDATE INVENTORY 
SET STOCK = STOCK + (4-(4*0.05))
WHERE PRODUCT_ID = 2;

END;
COMMIT;

EXCEPTION
WHEN OTHERS ROLLBACK TO STOCK_UPDATE;
        DBMS_OUTPUT.PUT_LINE('transaction rolled back due to an error'||SQLERRM);
END;

CREATE TABLE BANK_ACCOUNTS (
    ACCOUNT_ID NUMBER PRIMARY KEY,
    BALANCE NUMBER,
    ACCOUNT_TYPE VARCHAR2(20)
);

CREATE TABLE TRANSACTIONS (
    TRANSACTION_ID NUMBER PRIMARY KEY,
    ACCOUNT_ID NUMBER,
    TYPE VARCHAR2(20),
    AMOUNT NUMBER,
    TRANSACTION_DATE DATE,
    FOREIGN KEY (ACCOUNT_ID) REFERENCES BANK_ACCOUNTS(ACCOUNT_ID)
);

INSERT INTO BANK_ACCOUNTS (ACCOUNT_ID, BALANCE, ACCOUNT_TYPE) VALUES (1,1000,'SAVINGS');
INSERT INTO BANK_ACCOUNTS (ACCOUNT_ID, BALANCE, ACCOUNT_TYPE) VALUES (2,500,'CHECKING');

INSERT INTO TRANSACTIONS (TRANSACTION_ID, ACCOUNT_ID, TYPE, AMOUNT, TRANSACTION_DATE) 
VALUES (101, 1, 'DEBIT', 0, SYSDATE);
INSERT INTO TRANSACTIONS (TRANSACTION_ID, ACCOUNT_ID, TYPE, AMOUNT, TRANSACTION_DATE) 
VALUES (102, 2, 'CREDIT', 0, SYSDATE);

DECLARE
TRANSFER_AMOUNT := 200;
TRANSACTION_FEE NUMBER;
SENDER_BALANCE NUMBER;

BEGIN
TRANSFER_FEE:= TRANSFER_AMOUNT * 0.02;
SAVEPOINT BALANCE_UPDATED
UPDATE BANK_ACCOUNTS
SET BALANCE = BALANCE - (TRANSFER_AMOUNT + TRANSACTION_FEE) 
WHERE ACCOUNT_ID = 1;

SELECT BALANCE INTO SENDER_BALANCE
    FROM BANK_ACCOUNTS
    WHERE ACCOUNT_ID = 1;
    
IF SENDER_BALANCE < 0
ROLLBACK BACK TO BALANCE_UPDATED;
DBMS_OUTPUT.PUT_LINE('Transaction failed');
RETURN; 
END IF;

INSERT INTO TRANSACTIONS (TRANSACTION_ID, ACCOUNT_ID, TYPE, AMOUNT, TRANSACTION_DATE)
VALUES (103, 1, 'DEBIT', TRANSFER_AMOUNT + TRANSACTION_FEE, SYSDATE);

   UPDATE BANK_ACCOUNTS
    SET BALANCE = BALANCE + TRANSFER_AMOUNT
    WHERE ACCOUNT_ID = 2;

    IF SQL%ROWCOUNT = 0 THEN
        ROLLBACK TO BALANCE_UPDATED;
        DBMS_OUTPUT.PUT_LINE('transaction failed, not able to credit receiver account');
        RETURN;
    END IF;

    INSERT INTO TRANSACTIONS (TRANSACTION_ID, ACCOUNT_ID, TYPE, AMOUNT, TRANSACTION_DATE)
    VALUES (104, 2, 'CREDIT', TRANSFER_AMOUNT, SYSDATE);

    COMMIT;
    DBMS_OUTPUT.PUT_LINE('transaction successful '||TRANSFER_AMOUNT||' transferred with a fee of '||TRANSACTION_FEE);

EXCEPTION
    WHEN OTHERS THEN ROLLBACK TO BALANCE_UPDATED;
        DBMS_OUTPUT.PUT_LINE('transaction cant happen cuz of an error'||SQLERRM);
END;


CREATE TABLE CUSTOMERS (
    CUSTOMER_ID NUMBER PRIMARY KEY,
    NAME VARCHAR2(50)
);

CREATE TABLE LOYALTY_PROGRAM (
    CUSTOMER_ID NUMBER PRIMARY KEY,
    POINTS_EARNED NUMBER DEFAULT 0,
    POINTS_REDEEMED NUMBER DEFAULT 0,
    FOREIGN KEY (CUSTOMER_ID) REFERENCES CUSTOMERS(CUSTOMER_ID)
);

INSERT INTO CUSTOMERS (CUSTOMER_ID, NAME) VALUES (1,'Mujtaba Saqib');
INSERT INTO CUSTOMERS (CUSTOMER_ID, NAME) VALUES (2,'Hilal Aziz');

INSERT INTO LOYALTY_PROGRAM (CUSTOMER_ID, POINTS_EARNED, POINTS_REDEEMED) VALUES (1,100,20);
INSERT INTO LOYALTY_PROGRAM (CUSTOMER_ID, POINTS_EARNED, POINTS_REDEEMED) VALUES (2,150,50);

DECLARE
    PURCHASE_AMOUNT NUMBER := 600;
    POINTS_TO_AWARD NUMBER;
BEGIN
    IF PURCHASE_AMOUNT > 500 THEN
        POINTS_TO_AWARD := PURCHASE_AMOUNT * 1.5;
    ELSE
        POINTS_TO_AWARD := PURCHASE_AMOUNT;
    END IF;

    SAVEPOINT POINTS_UPDATED;

    UPDATE LOYALTY_PROGRAM
    SET POINTS_EARNED = POINTS_EARNED + POINTS_TO_AWARD
    WHERE CUSTOMER_ID = 1;

    IF SQL%ROWCOUNT = 0 THEN
        ROLLBACK TO POINTS_UPDATED;
        DBMS_OUTPUT.PUT_LINE('transaction failed,cant update points');
        RETURN;
    END IF;

    COMMIT;
    DBMS_OUTPUT.PUT_LINE('transaction successful ' ||POINTS_TO_AWARD|| ' points awarded');

EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK TO POINTS_UPDATED;
        DBMS_OUTPUT.PUT_LINE('transaction failed due to an error ' ||SQLERRM);
END;


CREATE TABLE orders (
    order_id INT PRIMARY KEY,
    customer_id INT,
    order_date DATE,
    total_amount DECIMAL(10, 2),
    status VARCHAR(50)
);

CREATE TABLE payments (
    payment_id INT PRIMARY KEY,
    order_id INT,
    payment_date DATE,
    payment_amount DECIMAL(10, 2),
    payment_method VARCHAR(50),
    FOREIGN KEY (order_id) REFERENCES orders(order_id)
);

CREATE TRIGGER after_insert_payment
AFTER INSERT ON payments
FOR EACH ROW
BEGIN
    DECLARE total_paid DECIMAL(10, 2);
    SELECT SUM(payment_amount) INTO total_paid
    FROM payments
    WHERE order_id = NEW.order_id;
    IF total_paid >= (SELECT total_amount FROM orders WHERE order_id = NEW.order_id) THEN
        UPDATE orders
        SET status = 'completed'
        WHERE order_id = NEW.order_id;
    ELSE
        UPDATE orders
        SET status = 'pending'
        WHERE order_id = NEW.order_id;
    END IF;
END;

CREATE TRIGGER after_update_payment
AFTER UPDATE ON payments
FOR EACH ROW
BEGIN
    DECLARE total_paid DECIMAL(10, 2);
    SELECT SUM(payment_amount) INTO total_paid
    FROM payments
    WHERE order_id = NEW.order_id;
    IF total_paid >= (SELECT total_amount FROM orders WHERE order_id = NEW.order_id) THEN
        UPDATE orders
        SET status = 'completed'
        WHERE order_id = NEW.order_id;
    ELSE
        UPDATE orders
        SET status = 'pending'
        WHERE order_id = NEW.order_id;
    END IF;
END;

CREATE TRIGGER after_delete_payment
AFTER DELETE ON payments
FOR EACH ROW
BEGIN
    DECLARE total_paid DECIMAL(10, 2);
    SELECT SUM(payment_amount) INTO total_paid
    FROM payments
    WHERE order_id = OLD.order_id;
    IF total_paid = 0 THEN
        UPDATE orders
        SET status = 'cancelled'
        WHERE order_id = OLD.order_id;
    ELSEIF total_paid < (SELECT total_amount FROM orders WHERE order_id = OLD.order_id) THEN
        UPDATE orders
        SET status = 'pending'
        WHERE order_id = OLD.order_id;
    END IF;
END;

START TRANSACTION;

INSERT INTO orders (order_id, customer_id, order_date, total_amount, status)
VALUES (1, 101, '2024-12-04', 500.00, 'pending');

INSERT INTO payments (payment_id, order_id, payment_date, payment_amount, payment_method)
VALUES (1, 1, '2024-12-04', 250.00, 'credit');

INSERT INTO payments (payment_id, order_id, payment_date, payment_amount, payment_method)
VALUES (2, 1, '2024-12-04', 250.00, 'debit');

COMMIT;

START TRANSACTION;

INSERT INTO orders (order_id, customer_id, order_date, total_amount, status)
VALUES (2, 102, '2024-12-04', 600.00, 'pending');

INSERT INTO payments (payment_id, order_id, payment_date, payment_amount, payment_method)
VALUES (3, 2, '2024-12-04', 700.00, 'credit');

ROLLBACK;

